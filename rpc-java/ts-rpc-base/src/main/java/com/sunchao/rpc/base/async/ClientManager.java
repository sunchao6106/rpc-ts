package com.sunchao.rpc.base.async;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.sunchao.rpc.base.async.support.DefaultFuture;
import com.sunchao.rpc.base.metadata.Request;
import com.sunchao.rpc.base.metadata.Response;
import com.sunchao.rpc.base.transport.Channel;
import com.sunchao.rpc.base.transport.SessionState;
import com.sunchao.rpc.common.logger.Logger;
import com.sunchao.rpc.common.logger.LoggerFactory;

/**
 * This class manages the socket I/O for the client and the asychronous request. 
 * 
 * @author <a href="mailto:sunchao6106@163.com">sunchao</a>
 *
 */
public class ClientManager extends SessionState {
	
	private static final Logger LOGGER = LoggerFactory.getLogger(ClientManager.class);
	
	/**
	 * the map store the request which be generated by client but not send to remote-side.
	 */
	private static final Map<Long, DefaultFuture> PENDING_CALLS = new ConcurrentHashMap<Long, DefaultFuture>();
	
	/**
	 * the map store the request which be generated by client that used transport channel.
	 */
	private static final Map<Long, Channel> CHANNELS = new ConcurrentHashMap<Long, Channel>();
	
	/**
	 * the Map store the request which has send but pend the response.
	 */
	private static final Map<Long,DefaultFuture> TIMEOUT_WATCH_MAP = new ConcurrentHashMap<Long, DefaultFuture>();
	
	/**
	 * register the asynchronous rpc remote invocation future.
	 * 
	 * @param id  the remote request id.
	 * @param future  the asynchronous future.
	 * @param channel the underlying transport channel.
	 */
	public static void registerPendingRequest(DefaultFuture future) {
		PENDING_CALLS.put(future.getId(), future);
		CHANNELS.put(future.getId(), future.getChannel());
	}
	
	/**
	 * Note that, there operation called by the client-side.
	 * and when the client-side cancel the remote invocation
	 * before the timeout & response non-prepared, the operation
	 * will remove the {@link #PENDING_CALLS} when the send operation not
	 * start or set the cancel flag <code>true</code> for the send operation
	 * started but has not return response.
	 * 
	 * @param future
	 */
	public static void cancelPending(DefaultFuture future) {
	     PENDING_CALLS.remove(future.getId());
	     CHANNELS.remove(future.getId());
	}
	
	//start any new remote invocation
	public static boolean startPendingSend(Channel channel, Request request) {
		DefaultFuture future = PENDING_CALLS.remove(request.getId());
		if (future == null) { //client cancel. and there just logger info.
			if (LOGGER.isInfoEnabled()) {
				LOGGER.info("the request: " + request  + ", has been cancelled by client before send.");
			}
			return false;
		}
		future.setSend();
		TIMEOUT_WATCH_MAP.put(request.getId(),future);	
		return true;
	}
	
	public static boolean hasFuture(Channel channel) {
		return CHANNELS.containsValue(channel);
	}
	
	public static DefaultFuture getFuture(long id) {
		return PENDING_CALLS.get(id);
	}
	
	/**
	 * Receive the response from the underlying socket channel.
	 * 
	 * @param channel
	 * @param response
	 */
	public static void received(Channel channel, Response response) {
		DefaultFuture future = TIMEOUT_WATCH_MAP.remove(response.getrId());
		if (future != null) {
			future.setResponse(response);
			CHANNELS.remove(response.getrId());
		} else {
			if ((CHANNELS.remove(response.getrId())) != null) { 
				LOGGER.warn("The timeout response finally returned at " 
							    + (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date()))
							    + ", response " + response
							    + (channel == null ? "" : ", channel: " + channel.getLocalAddress().toString()
							    		+ "-> " + channel.getRemoteAddress().toString()));
			} else {
				if (LOGGER.isInfoEnabled()) {
					LOGGER.info("client-side already cancel the remote invocation operation");
				}
			}
		}
	}

	



/*	private final SelectThread selectThead;
	//private final ConcurrentLinkedQueue<Integer> pendingCalls = new ConcurrentLinkedQueue<Integer>();
	
	private static final UncaughtExceptionHandler uncaught_exception_handler = 
			new UncaughtExceptionHandler() {
		public void uncaughtException(Thread t, Throwable e) {
			LOGGER.error("from " + t.getName(), e);
		}
	};*/
	
/*	public ClientManager() throws IOException {
		this.selectThead = new SelectThread();
	}*/
	
	
	/**
	 * 
	 * @author <a href="mailto:sunchao6106@163.com">sunchao</a>
	 *
	 */
	private static class TimeoutWatcherWorker implements Runnable {
		
		public void run() {
			while (true) {
				try {
					for (DefaultFuture future : TIMEOUT_WATCH_MAP.values()) {
						if (future == null || future.isDone()) 
							continue;
						if (System.currentTimeMillis() - future.getStart() > future.getTimeout()) {
							//deal with the timeout.
							Response timeoutResponse = new Response(future.getId());
							//set the error state code.
							timeoutResponse.setStatus_code(future.hasSend() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);
							timeoutResponse.setErrorMsg(DefaultFuture.getTimeoutMessage(true, future));
							received(future.getChannel(), timeoutResponse);
						}
					}
					Thread.sleep(40);
				} catch (Throwable t) {
					LOGGER.error("exception when scan the timeout invocation of remote." , t);
				}
			}
		}	
	
	}
	

	
	
/*	private class SelectThread extends Thread {
		private final Selector selector;
		private volatile boolean running;
		private final TreeSet<Integer> timeoutWatchSet = new TreeSet<Integer>();
		
		public SelectThread() throws IOException {
			setUncaughtExceptionHandler(uncaught_exception_handler);
			this.selector = SelectorProvider.provider().openSelector();
			this.running = true;
			this.setName("RPC-ClientManager#SelectorThread " + this.getId());

			setDaemon(true);
		}
		
		public Selector getSelector() {
			return selector;
		}
		
		public void finish() {
			running = false;
			selector.wakeup();
		}
		
		public void run() {
			
		}
	}
		private static class AsyncRemoteInvocationTimeoutComparator implements Comparator<DefaultFuture> {

		public int compare(DefaultFuture left, DefaultFuture right) {
		     if (left.getTimeoutTimeStamp() == right.getTimeoutTimeStamp()) {
		    	 return (int) (left.getId() - right.getId());
		     } else {
		    	 return (int) (left.getTimeoutTimeStamp() - right.getTimeoutTimeStamp());
		     }
		}	
	}*/
	
	static {
		Thread scanThread = new Thread(new TimeoutWatcherWorker(), "RPC-ClientManager#TimeoutScanThread#001");
		scanThread.setDaemon(true); //when the main thread closing , it atomic close.
		scanThread.start();
	}
}
